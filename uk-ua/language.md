* * *

layout: default language: 'en' version: '0.11' menu:


- text: 'Organizing code in files and namespaces' url: '#organizing-code-in-files-and-namespaces'
- text: 'Instruction separation' url: '#instruction-separation'
- text: 'Comments' url: '#comments'
- text: 'Variable declarations' url: '#variable-declarations'
- text: 'Variable scope' url: '#variable-scope'
- text: 'Super globals' url: '#super-globals'
- text: 'Local symbol table' url: '#local-symbol-table'

* * *

# Базовий синтаксис

У цьому розділі ми обговоримо організацію файлів, простори імен, оголошення змінних, різні синтаксичні конвенції та кілька інших загальних понять.

<a name='organizing-code-in-files-and-namespaces'></a>

## Розміщення коду в файлах та простори імен

У PHP ви можете розмістити код в будь-який файл, без конкретної структури. У Zephir кожен файл мусить містити клас (і тільки один клас). Кожен клас повинен мати простір імен, а структура каталогів повинна відповідати іменам класів та просторам імен. (Це схоже на PSR-4-автозавантажувальну конвенцію, за винятком того, що вона застосовується самою мовою.)

Наприклад, з огляду на наступну структуру кожен файл має мати наступні класи:

```bash
mylibrary/
    router/
        exception.zep # MyLibrary\Router\Exception
    router.zep # MyLibrary\Router
```

Клас у `mylibrary/router.zep`:

```zephir
namespace MyLibrary;

class Router
{

}
```

Клас у `mylibrary/router/exception.zep`:

```zephir
namespace MyLibrary\Router;

class Exception extends \Exception
{

}
```

Zephir викине виняток (exception) компілятора, якщо файл або клас не знаходяться в очікуваному файлі, або навпаки.

<a name='instruction-separation'></a>

## Розділення інструкцій

Можливо, ви вже помітили, що в прикладах коду в попередньому розділі було дуже мало крапок з комою. Ви можете використовувати крапку з комою для відокремлення тверджень та виразів, як у Java, C/C++, PHP та подібних мовах:

```zephir
myObject->myMethod(1, 2, 3); echo "world";
```

<a name='comments'></a>

## Коментарі

Zephir підтримує коментарі в стилі 'C'/'C++'. Це однорядкові коментарі з `// ...`, та багаторядкові з `/* ... */`:

```zephir
// це однорядковий коментар

/**
 * це багаторядковий
 * коментар
 */
```

У більшості мов коментарі це просто текст, який ігнорується компілятором/інтерпретатором. У Zephir-і багаторядкові коментарі також використовуються як док-блоки (docblocks) і вони експортуються до згенерованого коду, так що вони - частина мови!

Якщо док-блок не знаходиться там, де він очікується, компілятор викине виключення.

<a name='variable-declarations'></a>

## Оголошення змінних

У Zephir-і всі змінні, які використовуються в даній області видимості мають бути оголошені. Це дає компілятору можливість виконати оптимізацію та перевірки. Змінні мають бути унікальними ідентифікаторами. Ключові слова не можуть бути іменами змінних.

```zephir
// Оголошення змінних для одного і того ж типу в тій же інструкції
var a, b, c;

// Оголошення кожної змінної в окремому рядку
var a;
var b;
var c;
```

Змінні можуть мати початкове сумісне значення:

```zephir
// Оголошення змінних зі значеннями за замовчуванням
var a = "hello", b = 0, c = 1.0;
int d = 50; bool some = true;
```

Імена змінних чутливі до регістру, наступні змінні є різними:

```zephir
// Різні змінні
var somevalue, someValue, SomeValue;
```

<a name='variable-scope'></a>

## Область видимості

Усі оголошені в методі змінні залишаються в його локальній області видимості:

```zephir
namespace Test;

class MyClass
{
    public function someMethod1()
    {
        int a = 1, b = 2;
        return a + b;
    }

    public function someMethod2()
    {
        int a = 3, b = 4;
        return a + b;
    }
}
```

<a name='super-global'></a>

## Суперглобальні змінні

Zephir не підтримує глобальні змінні - доступу до глобальних змінних з PHP немає. Однак, ви можете отримати доступ до суперглобальних змінних PHP наступним чином:

```zephir
// Отримання значення з _POST
let price = _POST["price"];

// Читання даних з _SERVER
let requestMethod = _SERVER["REQUEST_METHOD"];
```

<a name='local-symbol-table'></a>

## Локальна таблиця символів

Кожен метод або контекст у PHP має таблицю символів, яка дозволяє вам записувати змінні у дуже гнучкий спосіб:

```php
<?php

$b = 100;
$a = "b";
echo $$a; // надрукує 100
```

У Zephir не передбачено реалізації цієї функціональності, тому що всі змінні компілюються до низькорівневих змінних, і немає ніякого способу дізнатися, які змінні існують у специфічному контексті. Якщо ви хочете створити змінну в поточній таблиці символів PHP, використайте такий синтаксис:

```zephir
// Встановлює змінну $name у PHP
let {"name"} = "hello";

// Встановлює змінну $price у PHP
let name = "price";
let {name} = 10.2;
```