% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Zephir Documentation}
\date{January 24, 2014}
\release{0.3.0}
\author{Zephir Team}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Reference}
\label{index:zephir-language}\label{index:reference}

\section{Welcome!}
\label{welcome:welcome}\label{welcome::doc}
Welcome to Zephir, an open source, high-level/domain specific language
designed to ease the creation and maintainability of extensions for PHP
with a focus on type and memory safety.


\subsection{Some features}
\label{welcome:some-features}
Zephir's main features are:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

Type system
 & 
dynamic/static
\\\hline

Memory safety
 & 
pointers or direct memory management aren't allowed
\\\hline

Compilation model
 & 
ahead of time
\\\hline

Memory model
 & 
task-local garbage collection
\\\hline
\end{tabulary}



\subsection{A small taste}
\label{welcome:a-small-taste}
The following code registers a class with a method that filters variables returning its
alphabetic characters:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * Filter}
\PYG{c+cm}{ */}
\PYG{k+kr}{class} \PYG{n+nx}{Filter}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Filters a string returning its alpha characters}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param string str}
\PYG{c+cm}{     */}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{alpha}\PYG{p}{(}\PYG{k+kr}{string} \PYG{n+nx}{str}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kr}{char} \PYG{n+nx}{ch}\PYG{p}{;} \PYG{k+kr}{string} \PYG{n+nx}{filtered} \PYG{o}{=} \PYG{l+s+s2}{""}\PYG{p}{;}

        \PYG{k}{for} \PYG{n+nx}{ch} \PYG{k}{in} \PYG{n+nx}{str} \PYG{p}{\PYGZob{}}
           \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{ch} \PYG{o}{\textgreater{}=} \PYG{l+s+s1}{'a'} \PYG{o}{\&\&} \PYG{n+nx}{ch} \PYG{o}{\textless{}=} \PYG{l+s+s1}{'z'}\PYG{p}{)} \PYG{o}{\textbar{}\textbar{}} \PYG{p}{(}\PYG{n+nx}{ch} \PYG{o}{\textgreater{}=} \PYG{l+s+s1}{'A'} \PYG{o}{\&\&} \PYG{n+nx}{ch} \PYG{o}{\textless{}=} \PYG{l+s+s1}{'Z'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
              \PYG{k+kd}{let} \PYG{n+nx}{filtered} \PYG{p}{.}\PYG{o}{=} \PYG{n+nx}{ch}\PYG{p}{;}
           \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n+nx}{filtered}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The class can be used from PHP as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{n+nv}{\PYGZdl{}filter} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{MyLibrary\PYGZbs{}Filter}\PYG{p}{();}
\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}filter}\PYG{o}{-\textgreater{}}\PYG{n+na}{alpha}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{01he}\PYG{l+s+si}{\PYGZdl{}l}\PYG{l+s+s2}{.lo?/1}\PYG{l+s+s2}{"}\PYG{p}{);} \PYG{c+c1}{// prints hello}
\end{Verbatim}


\section{Why Zephir?}
\label{motivation:why-zephir}\label{motivation::doc}
Today’s PHP applications must balance a number of concerns including stability, performance and functionality.
Every PHP application is based on a set of common components that are also base for most of the application.

These common components are libraries/frameworks or a combination of them. Once installed, frameworks rarely
change, being the foundation of the application they must be highly functional and also very fast.

Getting fast and robust libraries can be complicated due to high levels of abstraction that are
typically implemented on them. Given the condition that base libraries or frameworks rarely change,
there is an opportunity to build extensions that provide this functionality taking advantage of the
compilation improving performance and resource consumption.

With Zephir, you can implement object-oriented libraries/frameworks/applications that can be used from
PHP gaining important seconds that can make your application faster while improving the user experience.


\subsection{If You Are a PHP Programmer...}
\label{motivation:if-you-are-a-php-programmer}
PHP is one of the most popular languages in use for the development of web applications.
Dynamically typed and interpreted languages like PHP offer very high productivity due to their flexibility.

Since version 4 and then 5, PHP is based on the Zend Engine implementation. This is a virtual machine
that executes the PHP code from its bytecode representation. Zend Engine is almost present in every
PHP installation in the world, with Zephir, you can create extensions for PHP running under the
Zend Engine.

PHP is hosting Zephir, so they obviously have a lot of similarities, however; they have
important differences that give Zephir its own personality. For example, Zephir is more strict,
and it could be make you less productive compared to PHP due to the compilation step.


\subsection{If You Are a C Programmer...}
\label{motivation:if-you-are-a-c-programmer}
C is one of the most powerful and popular languages ever created. In fact, PHP is written in C,
which is one of the reasons why PHP extensions are available for it. C gives you the freedom to
manage memory, use low level types and even inline assembly routines.

However, developing big applications in C can take much longer than expected compared to PHP or Zephir
and some errors can be tricky to find if you aren't an experienced developer.

Zephir was designed to be safe, so it doesn't implement pointers or manual memory management, so
if you're a C programmer, you will feel Zephir less powerful but more friendly than C.


\subsection{Compilation vs Interpretation}
\label{motivation:compilation-vs-interpretation}
Compilation usually slows the development down; you will need a bit more of patience to make your code
compiled before running it. Moreover, the interpretation tends to reduce the performance in favor of
productivity. In some cases, there is no any noticeable difference between the speed of the
interpreted and compiled code.

Zephir requires compilation of your code, however, the functionality is used from PHP that is interpreted.

Once the code is compiled is not necessary to do so, however, interpreted code is interpreted each time
it is run. A developer can decide which parts of your application should be in Zephir and which not.


\subsection{Statically Typed Versus Dynamically Typed Languages}
\label{motivation:statically-typed-versus-dynamically-typed-languages}
In general speaking, in a static typed language, a variable is bound to a particular type for its lifetime.
Its type can’t be changed and it can only reference type-compatible instances and operations.
Languages like C/C++ were implemented with the scheme:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{hello}\PYG{l+s}{"}\PYG{p}{;} \PYG{c+c1}{// not allowed}
\end{Verbatim}

In dynamic typing, the type is bound to the value, not the variable. So, a variable might refer
to a value of a type, then be reassigned later to a value of an unrelated type. Javascript/PHP are examples of
a dynamic typed language:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;} \PYG{c+c1}{// allowed}
\end{Verbatim}

Despite their productivity advantages, dynamic languages may not be the best choices for all applications,
particularly for very large code bases and high-performance applications.

Optimizing the performance of a dynamic language like PHP is more challenging than for a static language like C.
In a static language, optimizers can exploit the type information to make decisions. In a dynamic language,
fewer such clues are available for the optimizer, making optimization choices harder.

While recent advancements in optimizations for dynamic languages are promising (like JIT compilation),
they lag behind the state of the art for static languages. So, if you require very high performance,
static languages are probably a safer choice.

Another small benefit of static languages is the extra checking the compiler performs.
A compiler can’t find logic errors, which are far more significant,
but a compiler can find errors in advance that in a dynamic language only can be
found in runtime.

Zephir is both statically and dynamically typed allowing you to take advantage from both sides where
possible.


\subsection{Compilation Scheme}
\label{motivation:compilation-scheme}
Zephir offers native code generation (currently via compilation to C), a compiler like gcc/clang/vc++
optimizes and compiles the code down to machine code. The following graph shows how the process works:
\begin{figure}[htbp]
\centering

\includegraphics{scheme.png}
\end{figure}

In addition to the ones provided by Zephir, Over time, compilers have been implemented
and matured a number of optimizations that improve the performance of compiled applications:
\begin{itemize}
\item {} 
\href{http://gcc.gnu.org/onlinedocs/gcc-4.1.0/gcc/Optimize-Options.html}{GCC optimizations}

\item {} 
\href{http://llvm.org/docs/Passes.html}{LLVM passes}

\item {} 
\href{http://msdn.microsoft.com/en-us/library/k1ack8f1.aspx}{Visual C/C++ optimizations}

\end{itemize}


\subsection{Code Protection}
\label{motivation:code-protection}
In some circumstances, the compilation does not significantly improve performance, this may be because the bottleneck is located
in the I/O bound of the application (quite likely) rather than compute/memory bound.
However, compiling code could also bring some level of intelectual protection to your application.
With Zephir, producing native binaries, you also get the ability to hide the code to users or customers.


\subsection{Conclusion}
\label{motivation:conclusion}
Zephir was not created to replace PHP or C, instead of this, we think it is a complement to them,
allowing developers to venture into code compilation and static typing.
Zephir is precisely an attempt to join good things from the C and PHP worlds,
looking for opportunities to make their applications faster.


\section{Introducing Zephir}
\label{intro::doc}\label{intro:introducing-zephir}
Zephir is a language that addresses the major needs of a PHP developer trying to write and compile code that
can be executed by PHP. It is a dynamically/statically typed, some of its features can be familiar to
PHP developers.

The name Zephir is a contraction of the words Zend Engine/PHP/Intermediate. While this suggests that the
pronunciation should be zephyr, the creators of Zephir actually pronounce it \href{http://translate.google.com/\#en/en/zaefire}{zaefire}.


\subsection{Hello World!}
\label{intro:hello-world}
Every language has its own ``Hello World!'' sample, in Zephir this introductory example showcases some important
features of this language.

Code in Zephir must be placed in classes. This language is intended to create object-oriented libraries/frameworks,
so code out of a class is not allowed. Also, a namespace is required:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * This is a sample class}
\PYG{c+cm}{ */}
\PYG{k+kr}{class} \PYG{n+nx}{Hello}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * This is a sample method}
\PYG{c+cm}{     */}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{say}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{echo} \PYG{l+s+s2}{"Hello World!"}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Once this class is compiled it produce the following code that is transparently compiled by gcc/clang/vc++:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef HAVE\PYGZus{}CONFIG\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include "config.h"}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include "php.h"}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include "php\PYGZus{}test.h"}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include "test.h"}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include "kernel}\PYG{c+cp}{/}\PYG{c+cp}{main.h"}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * This is a sample class}
\PYG{c+cm}{ */}
\PYG{n}{ZEPHIR\PYGZus{}INIT\PYGZus{}CLASS}\PYG{p}{(}\PYG{n}{Test\PYGZus{}Hello}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{ZEPHIR\PYGZus{}REGISTER\PYGZus{}CLASS}\PYG{p}{(}\PYG{n}{Test}\PYG{p}{,} \PYG{n}{Hello}\PYG{p}{,} \PYG{n}{hello}\PYG{p}{,} \PYG{n}{test\PYGZus{}hello\PYGZus{}method\PYGZus{}entry}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{SUCCESS}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * This is a sample method}
\PYG{c+cm}{ */}
\PYG{n}{PHP\PYGZus{}METHOD}\PYG{p}{(}\PYG{n}{Test\PYGZus{}Hello}\PYG{p}{,} \PYG{n}{say}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{php\PYGZus{}printf}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{\PYGZpc{}s}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{Hello World!}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Actually, it is not expected that a developer that uses Zephir must know or even understand C,
however, if you have any experience with compilers, php internals or the C language itself,
it would provide a more clear sceneario to the developer when working with Zephir.


\subsection{A Taste of Zephir}
\label{intro:a-taste-of-zephir}
In the following examples, we’ll describe just enough of the details, so you understand what’s going on.
The goal is to give you a sense of what programming in Zephir is like. We’ll explore the details of the
features in subsequent chapters.

The following example is very simple, it implements a class and a method with a small program that checks
the types of an array

Let’s examine the code in detail, so we can begin to learn Zephir syntax.
There are a lot of details in just a few lines of code! We’ll explain the general ideas here:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * MyTest (test/mytest.zep)}
\PYG{c+cm}{ */}
\PYG{k+kr}{class} \PYG{n+nx}{MyTest}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{someMethod}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+cm}{/* Variables must be declared */}
        \PYG{k+kd}{var} \PYG{n+nx}{myArray}\PYG{p}{;}
        \PYG{k+kr}{int} \PYG{n+nx}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nx}{length}\PYG{p}{;}

        \PYG{c+cm}{/* Create an array */}
        \PYG{k+kd}{let} \PYG{n+nx}{myArray} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"hello"}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{100.25}\PYG{p}{,} \PYG{k+kc}{false}\PYG{p}{,} \PYG{k+kc}{null}\PYG{p}{]}\PYG{p}{;}

        \PYG{c+cm}{/* Count the array into a 'int' variable */}
        \PYG{k+kd}{let} \PYG{n+nx}{length} \PYG{o}{=} \PYG{n+nb}{count}\PYG{p}{(}\PYG{n+nx}{myArray}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+cm}{/* Print value types */}
        \PYG{k}{while} \PYG{n+nx}{i} \PYG{o}{\textless{}} \PYG{n+nx}{length} \PYG{p}{\PYGZob{}}
            \PYG{k}{echo} \PYG{k}{typeof} \PYG{n+nx}{myArray}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
            \PYG{k+kd}{let} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n+nx}{myArray}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In the method, the first lines use the `var' and `int' keywords are used to declare a variable in the local scope.
Every variable used in a method must be declared with its respective type. This declaration is not optional,
it helps the compiler to report you about mistyped variables or about the use of variables out of their scope
which usually ends in runtime errors.

Dynamic variables are declared with the keyword `var'. These variables can be assigned and reassigned
to different types. On the other hand, we have `i' and `length' integer static typed variables
that can only have values of this type in the entire program execution.

In contrast with PHP, you are not required to put a dollar sign (\$) in front of variable names.

Zephir follows the same comment conventions as Java, C\#, C++, etc.
A //comment goes to the end of a line, while a /* comment */ can cross line boundaries.

Variables are by default immutable, this means that Zephir expects that most variables stay
unchanged. Variables that maintain their initial value can be optimized down by the compiler to static constants.
When the variable value needs to be changed, the keyword `let' must be used:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Create an array */}
\PYG{k+kd}{let} \PYG{n+nx}{myArray} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"hello"}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{100.25}\PYG{p}{,} \PYG{k+kc}{false}\PYG{p}{,} \PYG{k+kc}{null}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}

By default, arrays are dynamic like in PHP, they may contain values of different types.
Functions from the PHP userland can be called in Zephir code, in the example the function `count'
was called, the compiler can performs optimizations like avoid this call because it already knows the size of
the array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Count the array into a 'int' variable */}
\PYG{k+kd}{let} \PYG{n+nx}{length} \PYG{o}{=} \PYG{n+nb}{count}\PYG{p}{(}\PYG{n+nx}{myArray}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Parentheses in control flow statements are optional, you can also use them if you feel more confortable.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{n+nx}{i} \PYG{o}{\textless{}} \PYG{n+nx}{length} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{k}{typeof} \PYG{n+nx}{myArray}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
    \PYG{k+kd}{let} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

PHP only works with dynamic variables, methods always return dynamic variables, this means that if a
static typed variable is returned, in the PHP side, you will get a dynamic variable that can be used
in PHP code. Note that memory is automatically managed by the compiler, so you don't need to allocate or free
memory like in C, working in a similar way than PHP.


\section{Installation}
\label{install:installation}\label{install:zaefire}\label{install::doc}
To install Zephir, please follow these steps:


\subsection{Prerequisites}
\label{install:prerequisites}
To build a PHP extension and use Zephir you need the following requirements:
\begin{itemize}
\item {} 
gcc \textgreater{}= 4.x/clang \textgreater{}= 3.x

\item {} 
re2c 0.13 or later

\item {} 
gnu make 3.81 or later

\item {} 
autoconf 2.31 or later

\item {} 
automake 1.14 or later

\item {} 
libpcre3

\item {} 
php development headers and tools

\end{itemize}

If you're using Ubuntu, you can install the required packages this way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }sudo apt-get update
\PYG{n+nv}{\PYGZdl{} }sudo apt-get install git gcc make re2c php5 php5-dev libpcre3-dev
\end{Verbatim}

Since Zephir is written in PHP you need to have installed a recent version of PHP and it must be available in your console:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }php -v
PHP 5.5.7 \PYG{o}{(}cli\PYG{o}{)} \PYG{o}{(}built: Dec 14 2013 00:44:43\PYG{o}{)}
Copyright \PYG{o}{(}c\PYG{o}{)} 1997-2013 The PHP Group
Zend Engine v2.5.0, Copyright \PYG{o}{(}c\PYG{o}{)} 1998-2013 Zend Technologies
\end{Verbatim}

Also, make sure you have also the PHP development libraries installed along with your PHP installation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }phpize -v
Configuring \PYG{k}{for}:
PHP Api Version:         20121113
Zend Module Api No:      20121212
Zend Extension Api No:   220121212
\end{Verbatim}

You don't have to necessarely see the exact above output but it's important that these commands are available to start
developing with Zephir.


\subsection{Installing Zephir}
\label{install:installing-zephir}
Json-C is required by the Zephir parser to process the code, you can install it this way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }git clone https://github.com/json-c/json-c.git
\PYG{n+nv}{\PYGZdl{} }\PYG{n+nb}{cd }json-c
\PYG{n+nv}{\PYGZdl{} }sh autogen.sh
\PYG{n+nv}{\PYGZdl{} }./configure
\PYG{n+nv}{\PYGZdl{} }make \PYG{o}{\&\&} sudo make install
\end{Verbatim}

The Zephir compiler currently must be cloned from Github:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }git clone https://github.com/phalcon/zephir
\end{Verbatim}

Run the Zephir installer (this compiles/creates the parser):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }\PYG{n+nb}{cd }zephir
\PYG{n+nv}{\PYGZdl{} }./install -c
\end{Verbatim}


\subsection{Testing Installation}
\label{install:testing-installation}
Check if Zephir is available from any directory by executing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }zephir \PYG{n+nb}{help}
\end{Verbatim}


\section{Tutorial}
\label{tutorial::doc}\label{tutorial:tutorial}
Zephir and this book are intended for PHP developers which want to create C-extensions with a lower
complexity.

We assume that you are experienced in one or more other programming languages. We draw parallels to features
in PHP, C, Javascript, and other languages. If you know any of these languages, we’ll point out
similar features in Zephir, as well as many features that are new or different.


\subsection{Checking Installation}
\label{tutorial:checking-installation}
If you have successfully installed Zephir, you must be able to execute the following command in your console:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }zephir \PYG{n+nb}{help}
\end{Verbatim}

If everything is well, you should see the following help in your screen:

\begin{Verbatim}[commandchars=\\\{\}]
 \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}              \PYGZus{}\PYGZus{}    \PYGZus{}
/\PYGZus{}\PYGZus{}  /  \PYGZus{}\PYGZus{}\PYGZus{}  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}  / /\PYGZus{}  \PYG{o}{(}\PYGZus{}\PYG{o}{)}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
  / /  / \PYGZus{} \PYG{l+s+se}{\PYGZbs{}/} \PYGZus{}\PYGZus{} \PYG{l+s+se}{\PYGZbs{}/} \PYGZus{}\PYGZus{} \PYG{l+s+se}{\PYGZbs{}/} / \PYGZus{}\PYGZus{}\PYGZus{}/
 / /\PYGZus{}\PYGZus{}/  \PYGZus{}\PYGZus{}/ /\PYGZus{}/ / / / / / /
/\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/\PYG{l+s+se}{\PYGZbs{}\PYGZus{}}\PYGZus{}\PYGZus{}/ .\PYGZus{}\PYGZus{}\PYGZus{}/\PYGZus{}/ /\PYGZus{}/\PYGZus{}/\PYGZus{}/
         /\PYGZus{}/

Zephir version 0.3.0a

Usage:
    \PYG{n+nb}{command} \PYG{o}{[}options\PYG{o}{]}

Available commands:
    build               Generate/Compile/Install a Zephir extension
    clean               Cleans the generated object files in compilation
    compile             Compile a Zephir extension
    full-clean          Cleans the generated object files in compilation
    generate            Generates C code from the Zephir code
    \PYG{n+nb}{help                }Displays this \PYG{n+nb}{help}
\PYG{n+nb}{    }init \PYG{o}{[}namespace\PYG{o}{]}    Initializes a Zephir extension
    install             Installs the extension \PYG{o}{(}requires root password\PYG{o}{)}
    version             Shows Zephir version
\end{Verbatim}


\subsection{Extension Skeleton}
\label{tutorial:extension-skeleton}
The first thing we have to do is generate an extension skeleton, this will provide to our extension the basic
structure we need to start working. In our case, we're going to create an extension called ``utils'':

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }zephir init utils
\end{Verbatim}

After this, a directory called ``utils'' is created on the current working directory:

\begin{Verbatim}[commandchars=\\\{\}]
utils/
   ext/
   utils/
\end{Verbatim}

The directory ``ext/'' (inside utils) contains the code that is going to be used by the compiler to produce the extension.
The another directory created is ``utils'', this directory has the same as our extension. We will place Zephir code
in this directory.

We need to change the working directory to ``utils'' to start compiling our code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }\PYG{n+nb}{cd }utils
\PYG{n+nv}{\PYGZdl{} }ls
ext/ utils/ config.json
\end{Verbatim}

The directory listing will also show us a file called ``config.json'', this file contains configuration settings
we can use to alter the behavior of Zephir and/or this extension.


\subsection{Adding our first class}
\label{tutorial:adding-our-first-class}
Zephir is designed to generate object-oriented extensions. To start developing functionality we need to add
our first class to the extension.

As in many languages/tools, the first thing we want to do is see a ``hello world'' generated by Zephir
and check that everything is well. So our first class will be called ``Utils\textbackslash{}Greeting'' and it contains a method
printing ``hello world!''.

The code for this class must be placed in ``utils/utils/greeting.zep'':

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Utils}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Greeting}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kr}{static} \PYG{k+kd}{function} \PYG{n+nx}{say}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{echo} \PYG{l+s+s2}{"hello world!"}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Now, we need to tell Zephir that our project must be compiled and the extension generated:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }zephir build
\end{Verbatim}

Initially, and only for the first time, a number of internal commands are executed producing the necessary code and configurations
to export this class to the PHP extension, if everything goes well you will see the following message at the end
of the output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{...}
\PYG{x}{Extension installed!}
\PYG{x}{Add extension=utils.so to your php.ini}
\PYG{x}{Don't forget to restart your web server}
\end{Verbatim}

At the above step, it's likely that you would need to supply your root password in order to install the extension.
Finally, the extension must be added to the php.ini in order to be loaded by PHP. This is achieved
by adding the initialization directive: extension=utils.so to it.


\subsection{Initial Testing}
\label{tutorial:initial-testing}
Now that the extension was added to your php.ini, check whether the extension is being loaded properly by executing the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }php -m
\PYG{o}{[}PHP Modules\PYG{o}{]}
Core
date
libxml
pcre
Reflection
session
SPL
standard
tokenizer
utils
xdebug
xml
\end{Verbatim}

Extension ``utils'' must be part of the output indicating that the extension was loaded correctly. Now, let's see our
``hello world'' directly executed by PHP. To accomplish this, you can create a simple PHP file calling the static method we have
just created:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{k}{echo} \PYG{n+nx}{Utils\PYGZbs{}Greeting}\PYG{o}{::}\PYG{n+na}{say}\PYG{p}{(),} \PYG{l+s+s2}{"}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{"}\PYG{p}{;}
\end{Verbatim}

Congratulations!, you have your first extension running on PHP.


\subsection{A useful class}
\label{tutorial:a-useful-class}
The ``hello world'' class was fine to check if our enviroment was right, now, let's create some more useful classes.

The first useful class we are going to add to this extension will provide filtering facilities to users.
This class is called ``Utils\textbackslash{}Filter'' and its code must be placed in ``utils/utils/filter.zep'':

A basic skeleton to this class is the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Utils}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Filter}
\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The class contains filtering methods that help users to filter unwanted caracters from strings.
The first method is called ``alpha'' and its purpose is to filter only those characters that are ascii basic letters.
To begin, we are just going to traverse the string printing every byte to the standard output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Utils}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Filter}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{alpha}\PYG{p}{(}\PYG{k+kr}{string} \PYG{n+nx}{str}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kr}{char} \PYG{n+nx}{ch}\PYG{p}{;}

        \PYG{k}{for} \PYG{n+nx}{ch} \PYG{k}{in} \PYG{n+nx}{str} \PYG{p}{\PYGZob{}}
            \PYG{k}{echo} \PYG{n+nx}{ch}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

When invoking this method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{n+nv}{\PYGZdl{}f} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Utils\PYGZbs{}Filter}\PYG{p}{();}
\PYG{n+nv}{\PYGZdl{}f}\PYG{o}{-\textgreater{}}\PYG{n+na}{alpha}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{"}\PYG{p}{);}
\end{Verbatim}

You will see:

\begin{Verbatim}[commandchars=\\\{\}]
h
e
l
l
o
\end{Verbatim}

Checking every character in the string is straightforward, we now just could create another string with the right
filtered characters:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{class} \PYG{n+nx}{Filter}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{alpha}\PYG{p}{(}\PYG{k+kr}{string} \PYG{n+nx}{str}\PYG{p}{)} \PYG{o}{-\textgreater{}} \PYG{k+kr}{string}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kr}{char} \PYG{n+nx}{ch}\PYG{p}{;} \PYG{k+kr}{string} \PYG{n+nx}{filtered} \PYG{o}{=} \PYG{l+s+s2}{""}\PYG{p}{;}

        \PYG{k}{for} \PYG{n+nx}{ch} \PYG{k}{in} \PYG{n+nx}{str} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{ch} \PYG{o}{\textgreater{}=} \PYG{l+s+s1}{'a'} \PYG{o}{\&\&} \PYG{n+nx}{ch} \PYG{o}{\textless{}=} \PYG{l+s+s1}{'z'}\PYG{p}{)} \PYG{o}{\textbar{}\textbar{}} \PYG{p}{(}\PYG{n+nx}{ch} \PYG{o}{\textgreater{}=} \PYG{l+s+s1}{'A'} \PYG{o}{\&\&} \PYG{n+nx}{ch} \PYG{o}{\textless{}=} \PYG{l+s+s1}{'Z'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k+kd}{let} \PYG{n+nx}{filtered} \PYG{p}{.}\PYG{o}{=} \PYG{n+nx}{ch}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n+nx}{filtered}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The complete method can be tested as before:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{n+nv}{\PYGZdl{}f} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Utils\PYGZbs{}Filter}\PYG{p}{();}
\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}f}\PYG{o}{-\textgreater{}}\PYG{n+na}{alpha}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+si}{\PYGZdl{}he}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{02l3'121lo.}\PYG{l+s+s2}{"}\PYG{p}{);} \PYG{c+c1}{// prints "hello"}
\end{Verbatim}

In the following screencast you can watch how to create the extension explained in this tutorial:


\subsection{Conclusion}
\label{tutorial:conclusion}
This is a very simple tutorial and as you can see, it’s easy to start building extensions using Zephir.
We invite you to continue reading the manual so that you can discover additional features offered by Zephir!


\section{Basic Syntax}
\label{language::doc}\label{language:basic-syntax}
In this chapter, we’ll discuss the organization of files and namespaces, variable declarations,
miscellaneous syntax conventions, and a few other concepts.


\subsection{Organizing Code in Files and Namespaces}
\label{language:organizing-code-in-files-and-namespaces}
In PHP, you can place the code in any file without a specific structure. In Zephir, every file must contain
a class (and just one class). Every class must have a namespace and the directory structure must match
the names of classes and namespaces used.

For example, given the following structure, the classes in each file must be:

\begin{Verbatim}[commandchars=\\\{\}]
mylibrary/
        router/
                exception.zep \PYG{c}{\PYGZsh{} MyLibrary\PYGZbs{}Router\PYGZbs{}Exception}
        router.zep \PYG{c}{\PYGZsh{} MyLibrary\PYGZbs{}Router}
\end{Verbatim}

Class in mylibrary/router.zep:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Router}
\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Class in mylibrary/router/exception.zep:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary\PYGZbs{}Router}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Router} \PYG{k}{extends} \PYG{n+nx}{Exception}
\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Zephir will raise a compiler exception if a file or class is not located at the expected file or vice versa.


\subsection{Instruction separation}
\label{language:instruction-separation}
You may have already noticed that there were very few semicolons in the code examples in the previous chapter.
You can use semicolons to separate statements and expressions, as in Java, C/C++, PHP, and similar languages:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nx}{myObject}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myMethod}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{k}{echo} \PYG{l+s+s2}{"world"}\PYG{p}{;}
\end{Verbatim}


\subsection{Comments}
\label{language:comments}
Zephir supports `C'/'C++' comments, these are one line comments with // and multi line comments with /* ... */:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// this is one line comment}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * multi-line comment}
\PYG{c+cm}{ */}
\end{Verbatim}

In most languages, comments are simply text ignored by the compiler/interpreter. In Zephir,
multi-line comments are also used as docblocks, and they're exported to the generated code,
so they're part of the language!.

If a docblock is not located where is expected, the compiler will throw an exception.


\subsection{Variable Declarations}
\label{language:variable-declarations}
In Zephir, all variables used in a given scope must be declared. This process gives important information
to the compiler to perform optimizations and validations. Variables must be unique identifiers, and they cannot be
reserved words.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Declaring variables for the same type in the same instruction}
\PYG{k+kd}{var} \PYG{n+nx}{a}\PYG{p}{,} \PYG{n+nx}{b} \PYG{n+nx}{c}\PYG{p}{;}

\PYG{c+c1}{//Declaring each variable in different lines}
\PYG{k+kd}{var} \PYG{n+nx}{a}\PYG{p}{;}
\PYG{k+kd}{var} \PYG{n+nx}{b}\PYG{p}{;}
\PYG{k+kd}{var} \PYG{n+nx}{c}\PYG{p}{;}
\end{Verbatim}

Variables can optionally have an initial compatible default value, you can assign a new value to a variable
as often as you want:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Declaring variables with default values}
\PYG{k+kd}{var} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nx}{c} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{k+kr}{int} \PYG{n+nx}{d} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;} \PYG{k+kr}{bool} \PYG{n+nx}{some} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}
\end{Verbatim}

Variable names are case-sensitive, the following variables are different:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Different variables}
\PYG{k+kd}{var} \PYG{n+nx}{somevalue}\PYG{p}{,} \PYG{n+nx}{someValue}\PYG{p}{,} \PYG{n+nx}{SomeValue}\PYG{p}{;}
\end{Verbatim}


\subsection{Variable Scope}
\label{language:variable-scope}
All variables declared are locally scoped to the method where they were declared:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{someMethod1}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kr}{int} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{someMethod2}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kr}{int} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Super Globals}
\label{language:super-globals}
Zephir doesn't support global variables, accessing global variables from the PHP userland is not allowed.
However, you can access the PHP's super-globals as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Getting a value from \PYGZus{}POST}
\PYG{k+kd}{let} \PYG{n+nx}{price} \PYG{o}{=} \PYG{n+nb}{\PYGZus{}POST}\PYG{p}{[}\PYG{l+s+s2}{"price"}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Read a value from \PYGZus{}SERVER}
\PYG{k+kd}{let} \PYG{n+nx}{requestMethod} \PYG{o}{=} \PYG{n+nb}{\PYGZus{}SERVER}\PYG{p}{[}\PYG{l+s+s2}{"REQUEST\PYGZus{}METHOD"}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}


\subsection{Local Symbol Table}
\label{language:local-symbol-table}
Every method or context in PHP has a symbol table that allows to write variables in a very dynamic
way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{n+nv}{\PYGZdl{}b} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}a} \PYG{o}{=} \PYG{l+s+s2}{"}\PYG{l+s+s2}{b}\PYG{l+s+s2}{"}\PYG{p}{;}
\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}\PYGZdl{}a}\PYG{p}{;} \PYG{c+c1}{// prints 100}
\end{Verbatim}

Zephir does not implement this feature since all variables are compiled down to low level variables
and there is no way to know which variables do exist in a specific context. If you want to create
a variable in the current PHP symbol table, you can use the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Set variable \PYGZdl{}name in PHP}
\PYG{k+kd}{let} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"name"}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;}

\PYG{c+c1}{//Set variable \PYGZdl{}price in PHP}
\PYG{k+kd}{let} \PYG{n+nx}{name} \PYG{o}{=} \PYG{l+s+s2}{"price"}\PYG{p}{;}
\PYG{k+kd}{let} \PYG{p}{\PYGZob{}}\PYG{n+nx}{name}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{l+m+mf}{10.2}\PYG{p}{;}
\end{Verbatim}


\section{Types}
\label{types::doc}\label{types:types}
Zephir is both dynamic and static typed. In this chapter we highlight the supported types and
its behavior:


\subsection{Dynamic Type}
\label{types:dynamic-type}
Dynamic variables are exactly like the ones in PHP, they can be assigned and reassigned to
different types without restriction.

A dynamic variable must be declared with the keyword `var', the behavior is nearly the same as in PHP:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{a}\PYG{p}{,} \PYG{n+nx}{b}\PYG{p}{,} \PYG{n+nx}{c}\PYG{p}{;}

\PYG{c+c1}{// Initialize variables}
\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{;}

\PYG{c+c1}{// Change their values}
\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{l+s+s2}{"140"}\PYG{p}{;}

\PYG{c+c1}{// Perform operations between them}
\PYG{k+kd}{let} \PYG{n+nx}{c} \PYG{o}{=} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
\end{Verbatim}

They can have eight types:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

Type
 & 
Description
\\\hline

boolean
 & 
A boolean expresses a truth value. It can be either `true' or `false'.
\\\hline

integer
 & 
Integer numbers. The size of an integer is platform-dependent.
\\\hline

float/double
 & 
Floating point numbers. The size of a float is platform-dependent.
\\\hline

string
 & 
A string is series of characters, where a character is the same as a byte.
\\\hline

array
 & 
An array is an ordered map. A map is a type that associates values to keys
\\\hline

object
 & 
Object abstraction like in PHP
\\\hline

resource
 & 
A resource holds a reference to an external resource
\\\hline

null
 & 
The special NULL value represents a variable with no value
\\\hline
\end{tabulary}


Check more info about these types in the \href{http://www.php.net/manual/en/language.types.php}{PHP manual}


\subsubsection{Boolean}
\label{types:boolean}
A boolean expresses a truth value. It can be either `true' or `false':

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Integer}
\label{types:integer}
Integer numbers. The size of an integer is platform-dependent, although a maximum value of about two
billion is the usual value (that's 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18.
PHP does not support unsigned integers so Zephir has this restriction too:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{l+m+mi}{10050}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Integer overflow}
\label{types:integer-overflow}
Contrary to PHP, Zephir does not automatically checks for integer overflows, like in C if you are
doing operations that may return a big number you can use types such as `unsigned long' or `float'
to store them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{unsigned} \PYG{k+kr}{long} \PYG{n+nx}{my\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mi}{2147483648}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Float/Double}
\label{types:float-double}
Floating-point numbers (also known as ``floats'', ``doubles'', or ``real numbers'').
Floating-point literals are expressions with zero or more digits, followed by a period (.),
followed by zero or more digits. The size of a float is
platform-dependent, although a maximum of \textasciitilde{}1.8e308 with a
precision of roughly 14 decimal digits is a common value (the 64 bit IEEE format).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{number} \PYG{o}{=} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{n+nx}{b} \PYG{o}{=} \PYG{l+m+mf}{0.014}\PYG{p}{;}
\end{Verbatim}

Floating point numbers have limited precision. Although it depends on the system,
as PHP, Zephir uses the IEEE 754 double precision format, which will give a maximum
relative error due to rounding in the order of 1.11e-16.


\subsubsection{String}
\label{types:string}
A string is series of characters, where a character is the same as a byte. As PHP, Zephir only supports
a 256-character set, and hence does not offer native Unicode support.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{today} \PYG{o}{=} \PYG{l+s+s2}{"friday"}\PYG{p}{;}
\end{Verbatim}

In Zephir, string literals can only be specified using double quotes (like in C), single quotes are reserved
for chars.

The following escape sequences are supported in strings:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

Sequence
 & 
Description
\\\hline

\textbackslash{}t
 & 
Horizontal tab
\\\hline

\textbackslash{}n
 & 
Line feed
\\\hline

\textbackslash{}r
 & 
Carriage return
\\\hline

\textbackslash{} \textbackslash{}
 & 
Backslash
\\\hline

\textbackslash{}''
 & 
double-quote
\\\hline
\end{tabulary}


\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{today} \PYG{o}{=} \PYG{l+s+s2}{"\PYGZbs{}tfriday\PYGZbs{}n\PYGZbs{}r"}\PYG{p}{,}
    \PYG{n+nx}{tomorrow} \PYG{o}{=} \PYG{l+s+s2}{"\PYGZbs{}tsaturday"}\PYG{p}{;}
\end{Verbatim}

In Zephir, strings don't support variable parsing like in PHP, you can use concatenation instead:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{name} \PYG{o}{=} \PYG{l+s+s2}{"peter"}\PYG{p}{;}

\PYG{k}{echo} \PYG{l+s+s2}{"hello: "} \PYG{p}{.} \PYG{n+nx}{name}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Arrays}
\label{types:arrays}
The array implementation in Zephir is basically the same as in PHP: Ordered maps optimized for
several different uses; it can be treated as an array, list (vector), hash table (an implementation of a map),
dictionary, collection, stack, queue, and probably more. As array values can be other arrays, trees and
multidimensional arrays are also possible.

The syntax to define arrays is slightly different than in PHP:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Square braces must be used to define arrays}
\PYG{k+kd}{let} \PYG{n+nx}{myArray} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Double colon must be used to define hashes' keys}
\PYG{k+kd}{let} \PYG{n+nx}{myHash} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"first"}\PYG{o}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s2}{"second"}\PYG{o}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{"third"}\PYG{o}{:} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}

Only long and string values can be used as keys:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{myHash} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+s+s2}{"first"}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{:} \PYG{k+kc}{true}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{:} \PYG{k+kc}{null}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kd}{let} \PYG{n+nx}{myHash} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"first"}\PYG{o}{:} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+s+s2}{"second"}\PYG{o}{:} \PYG{l+s+s2}{"some string"}\PYG{p}{,} \PYG{l+s+s2}{"third"}\PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Objects}
\label{types:objects}
Zephir allows to instantiate, manipulate, call methods, read class constants, etc from PHP objects:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{myObject} \PYG{o}{=} \PYG{k}{new} \PYG{n+nb}{stdClass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{n+nx}{myObject}\PYG{o}{-\textgreater{}}\PYG{n+nx}{someProperty} \PYG{o}{=} \PYG{l+s+s2}{"my value"}\PYG{p}{;}
\end{Verbatim}


\subsection{Static Types}
\label{types:static-types}
Static typing allows the developer to declare and use some variable types available in C.
Variables can't change their type once they're declared as dynamic types. However, they allow
the compiler to do a better optimization job. The following types are supported:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

Type
 & 
Description
\\\hline

boolean
 & 
A boolean expresses a truth value. It can be either `true' or `false'.
\\\hline

integer
 & 
Signed integers. At least 16 bits in size.
\\\hline

unsigned integer
 & 
Unsigned integers. At least 16 bits in size.
\\\hline

char
 & 
Smallest addressable unit of the machine that can contain basic character set.
\\\hline

unsigned char
 & 
Same size as char, but guaranteed to be unsigned.
\\\hline

long
 & 
Long signed integer type. At least 32 bits in size.
\\\hline

unsigned long
 & 
Same as long, but unsigned.
\\\hline

float/double
 & 
Double precision floating-point type. The size is platform-dependent.
\\\hline

string
 & 
A string is series of characters, where a character is the same as a byte.
\\\hline
\end{tabulary}



\subsubsection{Boolean}
\label{types:id1}
A boolean expresses a truth value. It can be either `true' or `false'. Contrary to the dynamic behavior
static boolean types remain boolean (true or false) no mater what value is assigned to them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{boolean} \PYG{n+nx}{a}\PYG{p}{;}

\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{,}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{c+c1}{// automatically casted to true}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{null}\PYG{p}{,} \PYG{c+c1}{// automatically casted to false}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;} \PYG{c+c1}{// throws a compiler exception}
\end{Verbatim}


\subsubsection{Integer/Unsigned Integer}
\label{types:integer-unsigned-integer}
Integer values are like the integer member in dynamic values. Values assigned to integer variables
remain integer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{int} \PYG{n+nx}{a}\PYG{p}{;}

\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{70}\PYG{p}{,}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mf}{100.25}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 100}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{null}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;} \PYG{c+c1}{// throws a compiler exception}
\end{Verbatim}

Unsigned integers are like integers but they don't have sign, this means you can't store
negative numbers in these sort of variables:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 70}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mf}{100.25}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 100}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{null}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;} \PYG{c+c1}{// throws a compiler exception}
\end{Verbatim}

Unsigned integers are twice bigger than standard integers, assign unsigned integers to integers
may represent loss of data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nx}{uint} \PYG{n+nx}{a}\PYG{p}{,} \PYG{k+kr}{int} \PYG{n+nx}{b}\PYG{p}{;}

\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{2147483648}\PYG{p}{,}
    \PYG{n+nx}{b} \PYG{o}{=} \PYG{n+nx}{a}\PYG{p}{,} \PYG{c+c1}{// possible loss of data}
\end{Verbatim}


\subsubsection{Long/Unsigned Long}
\label{types:long-unsigned-long}
Long variables are twice bigger than integer variables, thus they can store bigger numbers,
As integers values assigned to long variables are automatically casted to this type:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{long} \PYG{n+nx}{a}\PYG{p}{;}

\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{70}\PYG{p}{,}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mf}{100.25}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 100}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{null}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;} \PYG{c+c1}{// throws a compiler exception}
\end{Verbatim}

Unsigned longs are like longs but they aren't signed, this means you can't store
negative numbers in these sort of variables:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 70}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mf}{100.25}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 100}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{null}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{,} \PYG{c+c1}{// automatically casted to 0}
    \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;} \PYG{c+c1}{// throws a compiler exception}
\end{Verbatim}

Unsigned longs are twice bigger than standard longs, assign unsigned longs to longs
may represent loss of data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{ulong} \PYG{n+nx}{a}\PYG{p}{,} \PYG{k+kr}{long} \PYG{n+nx}{b}\PYG{p}{;}

\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{4294967296}\PYG{p}{,}
    \PYG{n+nx}{b} \PYG{o}{=} \PYG{n+nx}{a}\PYG{p}{,} \PYG{c+c1}{// possible loss of data}
\end{Verbatim}


\subsubsection{Char/Unsigned Char}
\label{types:char-unsigned-char}
Char variables are the smallest addressable unit of the machine that can contain basic character set.
Every `char' variable represents every character in a string:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{char} \PYG{n+nx}{ch}\PYG{p}{,} \PYG{k+kr}{string} \PYG{n+nx}{name} \PYG{o}{=} \PYG{l+s+s2}{"peter"}\PYG{p}{;}

\PYG{k+kd}{let} \PYG{n+nx}{ch} \PYG{o}{=} \PYG{n+nx}{name}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// stores 't'}
\end{Verbatim}


\section{Operators}
\label{operators:php-manual}\label{operators:operators}\label{operators::doc}
Zephir's set of operators are similar to the ones PHP and also inherits some of their behaviors.


\subsection{Arithmetic Operators}
\label{operators:arithmetic-operators}
The following operators are supported:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

Operation
 & 
Example
\\\hline

Negation
 & 
-a
\\\hline

Addition
 & 
a + b
\\\hline

Substraction
 & 
a - b
\\\hline

Multiplication
 & 
a * b
\\\hline

Division
 & 
a / b
\\\hline

Modulus
 & 
a \% b
\\\hline
\end{tabulary}



\subsection{Comparison Operators}
\label{operators:comparison-operators}
Comparison operators depend on the type of variables compared, for example, if both
compared operands are dynamic variables the behavior is the same as in PHP:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline

a == b
 & 
Equal
 & 
TRUE if a is equal to b after type juggling.
\\\hline

a === b
 & 
Identical
 & 
TRUE if a is equal to b, and they are of the same type.
\\\hline

a != b
 & 
Not equal
 & 
TRUE if a is not equal to b after type juggling.
\\\hline

a \textless{}\textgreater{} b
 & 
Not equal
 & 
TRUE if a is not equal to b after type juggling.
\\\hline

a !== b
 & 
Not identical
 & 
TRUE if a is not equal to b, or they are not of the same type.
\\\hline

a \textless{} b
 & 
Less than
 & 
TRUE if a is strictly less than b.
\\\hline

a \textgreater{} b
 & 
Greater than
 & 
TRUE if a is strictly greater than b.
\\\hline

a \textless{}= b
 & 
Less than or equal to
 & 
TRUE if a is less than or equal to b.
\\\hline

a \textgreater{}= b
 & 
Greater than or equal to
 & 
TRUE if a is greater than or equal to b.
\\\hline
\end{tabulary}


Learn more about comparison of dynamic variables in the \href{http://www.php.net/manual/en/language.operators.comparison.php}{php manual}.


\subsection{Special Operators}
\label{operators:special-operators}
The following operators are supported:


\subsubsection{Empty}
\label{operators:empty}
This operator allows to check whether an expression is empty. `Empty' means the expression is null, is an empty string or an empty array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{someVar} \PYG{o}{=} \PYG{l+s+s2}{""}\PYG{p}{;}
\PYG{k}{if} \PYG{k}{empty} \PYG{n+nx}{someVar} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{l+s+s2}{"is empty!"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kd}{let} \PYG{n+nx}{someVar} \PYG{o}{=} \PYG{l+s+s2}{"hello"}\PYG{p}{;}
\PYG{k}{if} \PYG{o}{!}\PYG{k}{empty} \PYG{n+nx}{someVar} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{l+s+s2}{"is not empty!"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{Isset}
\label{operators:isset}
This operator checks whether a property or index has been defined in an array or object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{someArray} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"a"}\PYG{o}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s2}{"b"}\PYG{o}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{"c"}\PYG{o}{:} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{if} \PYG{k}{isset} \PYG{n+nx}{someArray}\PYG{p}{[}\PYG{l+s+s2}{"b"}\PYG{p}{]} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// check if the array has an index "b"}
    \PYG{k}{echo} \PYG{l+s+s2}{"yes, it has an index 'b'\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Using `isset' as return expression:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{k}{isset} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{p}{\PYGZob{}}\PYG{n+nx}{someProperty}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Fetch}
\label{operators:fetch}
`Fetch' is an operator that reduce a common operation in PHP into a single instruction:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{isset}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}myArray}\PYG{p}{[}\PYG{n+nv}{\PYGZdl{}key}\PYG{p}{]))} \PYG{p}{\PYGZob{}}
    \PYG{n+nv}{\PYGZdl{}value} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}myArray}\PYG{p}{[}\PYG{n+nv}{\PYGZdl{}key}\PYG{p}{];}
    \PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}value}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In Zephir, you can write the same code as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{k}{fetch} \PYG{n+nx}{value}\PYG{p}{,} \PYG{n+nx}{myArray}\PYG{p}{[}\PYG{n+nx}{key}\PYG{p}{]} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{n+nx}{value}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

`Fetch' only returns true if the `key' is a valid item in the array, only in that case, `value' is populated.


\subsubsection{Type Hints}
\label{operators:type-hints}
Zephir always tries to check whether an object implements methods and properties called/accessed on a variable that is inferred to be an object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{o} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{MyObject}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Zephir checks if "myMethod" is implemented on MyObject}
\PYG{n+nx}{o}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myMethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

However, due to the dynamism inherited from PHP, sometimes it is not easy to know the class of an object so Zephir can not produce errors reports effectively.
A type hint tells the compiler which class is related to a dynamic variable allowing the compiler to perform more compilation checks:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Tell the compiler that "o"}
\PYG{c+c1}{// is an instance of class MyClass}
\PYG{k+kd}{let} \PYG{n+nx}{o} \PYG{o}{=} \PYG{o}{\textless{}}\PYG{n+nx}{MyClass}\PYG{o}{\textgreater{}} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{\PYGZus{}myObject}\PYG{p}{;}
\PYG{n+nx}{o}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myMethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Branch Prediction Hints}
\label{operators:branch-prediction-hints}
What is branch prediction? Check this \href{http://igoro.com/archive/fast-and-slow-if-statements-branch-prediction-in-modern-processors/}{article out}. In environments where performance is very important, it may be useful to introduce these hints.

Consider the following example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{allPaths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for} \PYG{n+nx}{path} \PYG{k}{in} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{\PYGZus{}paths} \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{n+nx}{path}\PYG{o}{-\textgreater{}}\PYG{n+nx}{isAllowed}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{false} \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{App\PYGZbs{}Exception}\PYG{p}{(}\PYG{l+s+s2}{"error!!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{let} \PYG{n+nx}{allPaths}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{path}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The authors of the above code, know in advance that the condition that throws the exception is unlikely to happen. This means that 99.9\% of the time, our method executes that condition, but it is probably never evaluated as true. For the processor, this could be hard to know, so we could introduce a hint there:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{allPaths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for} \PYG{n+nx}{path} \PYG{k}{in} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{\PYGZus{}paths} \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{k}{unlikely} \PYG{n+nx}{path}\PYG{o}{-\textgreater{}}\PYG{n+nx}{isAllowed}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{false} \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{App\PYGZbs{}Exception}\PYG{p}{(}\PYG{l+s+s2}{"error!!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{let} \PYG{n+nx}{allPaths}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{path}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Arrays}
\label{arrays:arrays}\label{arrays::doc}\label{arrays:article-out}
Array manipulation in Zephir provides a way to use PHP \href{http://www.php.net/manual/en/language.types.array.php}{arrays}.
An array is an implementation of a \href{http://en.wikipedia.org/wiki/Hash\_table}{hash table}.


\subsection{Creating Arrays}
\label{arrays:creating-arrays}
An array is created enclosing their elements in square brackets:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Creating an empty array}
\PYG{k+kd}{let} \PYG{n+nx}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Creating an array with elements}
\PYG{k+kd}{let} \PYG{n+nx}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Creating an array with elements of different types}
\PYG{k+kd}{let} \PYG{n+nx}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"first"}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//A multidimensional array}
\PYG{k+kd}{let} \PYG{n+nx}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}

As PHP, hashes or dictionaries are supported:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Creating a hash with string keys}
\PYG{k+kd}{let} \PYG{n+nx}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"foo"}\PYG{o}{:} \PYG{l+s+s2}{"bar"}\PYG{p}{,} \PYG{l+s+s2}{"bar"}\PYG{o}{:} \PYG{l+s+s2}{"foo"}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Creating a hash with numeric keys}
\PYG{k+kd}{let} \PYG{n+nx}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{o}{:} \PYG{l+s+s2}{"bar"}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{o}{:} \PYG{l+s+s2}{"foo"}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Creating a hash with mixed string and numeric keys}
\PYG{k+kd}{let} \PYG{n+nx}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{o}{:} \PYG{l+s+s2}{"bar"}\PYG{p}{,} \PYG{l+s+s2}{"foo"}\PYG{o}{:} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}


\subsection{Updating arrays}
\label{arrays:updating-arrays}
Arrays are updated in the same way as PHP using square brackets:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Updating an array with a string key}
\PYG{k+kd}{let} \PYG{n+nx}{elements}\PYG{p}{[}\PYG{l+s+s2}{"foo"}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{"bar"}\PYG{p}{;}

\PYG{c+c1}{//Updating an array with a numeric key}
\PYG{k+kd}{let} \PYG{n+nx}{elements}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{"bar"}\PYG{p}{;}
\end{Verbatim}


\subsection{Appending elements}
\label{arrays:appending-elements}
Elements can be appended at the end of the array as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Append an element to the array}
\PYG{k+kd}{let} \PYG{n+nx}{elements}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{"bar"}\PYG{p}{;}
\end{Verbatim}


\subsection{Reading elements from arrays}
\label{arrays:reading-elements-from-arrays}
Is possible to read array elements as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Getting an element using the string key "foo"}
\PYG{k+kd}{let} \PYG{n+nx}{foo} \PYG{o}{=} \PYG{n+nx}{elements}\PYG{p}{[}\PYG{l+s+s2}{"foo"}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Getting an element using the numeric key 0}
\PYG{k+kd}{let} \PYG{n+nx}{foo} \PYG{o}{=} \PYG{n+nx}{elements}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}


\section{Classes and Objects}
\label{oop:classes-and-objects}\label{oop:hash-table}\label{oop::doc}
Zephir promotes object-oriented programming, this is why you can only export methods
and classes in extensions, also you will see that most of the time, runtime errors raise
exceptions instead of fatal errors or warnings.


\subsection{Classes}
\label{oop:classes}
Every Zephir file must implement a class or an interface (and just once). A class structure
is very similar to a PHP class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * This is a sample class}
\PYG{c+cm}{ */}
\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Implementing Methods}
\label{oop:implementing-methods}
The ``function'' keyword introduces a method. Methods implements the usual visibility modifiers available
in PHP, explicity set a visibility modifier is mandatory in Zephir:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{myPublicMethod}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// ...}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{protected} \PYG{k+kd}{function} \PYG{n+nx}{myProtectedMethod}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// ...}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{private} \PYG{k+kd}{function} \PYG{n+nx}{myPrivateMethod}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// ...}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Methods can receive required and optional parameters:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * All parameters are required}
\PYG{c+cm}{     */}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{doSum1}\PYG{p}{(}\PYG{n+nx}{a}\PYG{p}{,} \PYG{n+nx}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Just 'a' is required, 'b' is optional and it has a default value}
\PYG{c+cm}{     */}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{doSum2}\PYG{p}{(}\PYG{n+nx}{a}\PYG{p}{,} \PYG{n+nx}{b}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Both parameters are optional}
\PYG{c+cm}{     */}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{doSum3}\PYG{p}{(}\PYG{n+nx}{a}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nx}{b}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Parameters are required and their values must be integer}
\PYG{c+cm}{     */}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{doSum4}\PYG{p}{(}\PYG{k+kr}{int} \PYG{n+nx}{a}\PYG{p}{,} \PYG{k+kr}{int} \PYG{n+nx}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Static typed with default values}
\PYG{c+cm}{     */}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{doSum4}\PYG{p}{(}\PYG{k+kr}{int} \PYG{n+nx}{a}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{int} \PYG{n+nx}{b}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{+} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{Public Visibility}
\label{oop:public-visibility}
Methods marked as ``public'' are exported to the PHP extension, this means that public methods
are visible to the PHP code as well to the extension itself.


\subsubsection{Protected Visibility}
\label{oop:protected-visibility}
Methods marked as ``protected'' are exported to the PHP extension, this means that protected methods
are visible to the PHP code as well to the extension itself. However, protected methods can only
be called in the scope of the class or in classes that inherit them.


\subsubsection{Private Visibility}
\label{oop:private-visibility}
Methods marked as ``private'' are not exported to the PHP extension, this means that private methods
are only visible to the class where they're implemented.


\subsection{Implementing Properties}
\label{oop:implementing-properties}
Class member variables are called ``properties''. By default, they act as PHP properties.
Properties are exported to the PHP extension and are visibles from PHP code.
Properties implement the usual visibility modifiers available in PHP, explicity set
a visibility modifier is mandatory in Zephir:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{n+nx}{myProperty1}\PYG{p}{;}

    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty2}\PYG{p}{;}

    \PYG{k+kr}{private} \PYG{n+nx}{myProperty3}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Within class methods non-static properties may be accessed by using -\textgreater{} (Object Operator): this-\textgreater{}property
(where property is the name of the property):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty}\PYG{p}{;}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{setMyProperty}\PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{myProperty}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myProperty} \PYG{o}{=} \PYG{n+nx}{myProperty}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{getMyProperty}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myProperty}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Properties can have literal compatible default values. These values must be able to be evaluated at
compile time and must not depend on run-time information in order to be evaluated:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty1} \PYG{o}{=} \PYG{k+kc}{null}\PYG{p}{;}
    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty2} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty3} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{;}
    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty4} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty5} \PYG{o}{=} \PYG{l+s+s2}{"my value"}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Updating Properties}
\label{oop:updating-properties}
Properties can be updated by accesing them using the `-\textgreater{}' operator:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myProperty} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\end{Verbatim}

Zephir checks that properties do exist when a program is accesing them, if a property is not declared you will get a compiler exception:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{CompilerException: Property '\PYGZus{}optionsx' is not defined on class '\PYGZus{}optionsx' in /Users/scott/cphalcon/phalcon/cache/backend.zep on line 62}

\PYG{x}{      this-\textgreater{}\PYGZus{}optionsx = options;}
\PYG{x}{      ------------\PYGZca{}}
\end{Verbatim}

If you want to avoid this compiler validation or just create a property dynamically, you can enclose the property name using string quotes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"myProperty"}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\end{Verbatim}

You can also use a simple variable to update a property, the property name will be taken from the variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{someProperty} \PYG{o}{=} \PYG{l+s+s2}{"myProperty"}\PYG{p}{;}
\PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{p}{\PYGZob{}}\PYG{n+nx}{someProperty}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\end{Verbatim}


\subsection{Reading Properties}
\label{oop:reading-properties}
Properties can be read by accesing them using the `-\textgreater{}' operator:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{echo} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myProperty}\PYG{p}{;}
\end{Verbatim}

As when updating, properties can be dynamically read this way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Avoid compiler check or read a dynamic user defined property}
\PYG{k}{echo} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"myProperty"}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{//Read using a variable name}
\PYG{k+kd}{let} \PYG{n+nx}{someProperty} \PYG{o}{=} \PYG{l+s+s2}{"myProperty"}\PYG{p}{;}
\PYG{k}{echo} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{p}{\PYGZob{}}\PYG{n+nx}{someProperty}\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Class Constants}
\label{oop:class-constants}
Class may contain class constants that remain the same and unchangeable once the extension is compiled.
Class constants are exported to the PHP extension allowing them to be used from PHP.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{const} \PYG{n+nx}{MYCONSTANT1} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{k+kr}{const} \PYG{n+nx}{MYCONSTANT2} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Class constants can be accessed using the class name and the static operator (::):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{const} \PYG{n+nx}{MYCONSTANT1} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{k+kr}{const} \PYG{n+nx}{MYCONSTANT2} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{someMethod}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n+nx}{MYCONSTANT1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Calling Methods}
\label{oop:calling-methods}
Methods can be called using the object operator (-\textgreater{}) as in PHP:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{protected} \PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}someHiddenMethod}\PYG{p}{(}\PYG{n+nx}{a}\PYG{p}{,} \PYG{n+nx}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{-} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{someMethod}\PYG{p}{(}\PYG{n+nx}{c}\PYG{p}{,} \PYG{n+nx}{d}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{\PYGZus{}someHiddenMethod}\PYG{p}{(}\PYG{n+nx}{c}\PYG{p}{,} \PYG{n+nx}{d}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Static methods must be called using the static operator (::):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{protected} \PYG{k+kr}{static} \PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}someHiddenMethod}\PYG{p}{(}\PYG{n+nx}{a}\PYG{p}{,} \PYG{n+nx}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{a} \PYG{o}{-} \PYG{n+nx}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kr}{static} \PYG{k+kd}{function} \PYG{n+nx}{someMethod}\PYG{p}{(}\PYG{n+nx}{c}\PYG{p}{,} \PYG{n+nx}{d}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k+kr}{self}\PYG{o}{:}\PYG{o}{:}\PYG{n+nx}{\PYGZus{}someHiddenMethod}\PYG{p}{(}\PYG{n+nx}{c}\PYG{p}{,} \PYG{n+nx}{d}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can call methods in a dynamic manner as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{protected} \PYG{n+nx}{adapter}\PYG{p}{;}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{setAdapter}\PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{adapter}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{adapter} \PYG{o}{=} \PYG{n+nx}{adapter}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{someMethod}\PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{methodName}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{adapter}\PYG{o}{-\textgreater{}}\PYG{p}{\PYGZob{}}\PYG{n+nx}{methodName}\PYG{p}{\PYGZcb{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Getter/Setter shortcuts}
\label{oop:getter-setter-shortcuts}
Like in C\#, you can use get/set/toString shortcuts in Zephir, this feature allows to easily write setters and getters for properties without explictly
implementing those methods as such.

For example, without shortcuts we could find code like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{Test}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty}\PYG{p}{;}

    \PYG{k+kr}{protected} \PYG{n+nx}{someProperty} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{setMyProperty}\PYG{p}{(}\PYG{n+nx}{myProperty}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myProperty} \PYG{o}{=} \PYG{n+nx}{myProperty}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{getMyProperty}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myProperty}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{setSomeProperty}\PYG{p}{(}\PYG{n+nx}{someProperty}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{someProperty} \PYG{o}{=} \PYG{n+nx}{someProperty}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{getSomeProperty}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{someProperty}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}\PYGZus{}toString}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{myProperty}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

 \PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can write the same code using shortcuts as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{App}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{protected} \PYG{n+nx}{myProperty} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{set}\PYG{p}{,} \PYG{n+nx}{get}\PYG{p}{,} \PYG{n+nx}{toString}
    \PYG{p}{\PYGZcb{}}\PYG{p}{;}

    \PYG{k+kr}{protected} \PYG{n+nx}{someProperty} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{set}\PYG{p}{,} \PYG{n+nx}{get}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

When the code is compiled those methods are exported as real methods but you don’t have to write them one by one.


\subsection{Return Type Hints}
\label{oop:return-type-hints}
Mthods in classes and interfaces can have return type hints, these will provide useful extra information to the compiler
to inform you about errors in your application. Consider the following example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{App}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{MyClass}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{getSomeData}\PYG{p}{(}\PYG{p}{)} \PYG{o}{-\textgreater{}} \PYG{k+kr}{string}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// this will throw a compiler exception}
        \PYG{c+c1}{// since the returned value (boolean) does not match}
        \PYG{c+c1}{// the expected returned type string}
        \PYG{k}{return} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{getSomeOther}\PYG{p}{(}\PYG{p}{)} \PYG{o}{-\textgreater{}} \PYG{o}{\textless{}}\PYG{n+nx}{App\PYGZbs{}MyInterface}\PYG{o}{\textgreater{}}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// this will throw a compiler exception}
        \PYG{c+c1}{// if the returned object does not implement}
        \PYG{c+c1}{// the expected interface App\PYGZbs{}MyInterface}
        \PYG{k}{return} \PYG{k}{new} \PYG{n+nx}{App\PYGZbs{}MyObject}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{process}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{myObject}\PYG{p}{;}

        \PYG{c+c1}{// the type-hint will tell the compiler that}
        \PYG{c+c1}{// myObject is an instance of a class}
        \PYG{c+c1}{// that implement App\PYGZbs{}MyInterface}
        \PYG{k+kd}{let} \PYG{n+nx}{myObject} \PYG{o}{=} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{getSomeOther}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// the compiler will check if App\PYGZbs{}MyInterface}
        \PYG{c+c1}{// implements a method called "someMethod"}
        \PYG{k}{echo} \PYG{n+nx}{myObject}\PYG{o}{-\textgreater{}}\PYG{n+nx}{someMethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Return Type: Void}
\label{oop:return-type-void}
Methods can also be marked as ‘void’. This means that a method is not allowed to return any data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{setConnection}\PYG{p}{(}\PYG{n+nx}{connection}\PYG{p}{)} \PYG{o}{-\textgreater{}} \PYG{k}{void}
\PYG{p}{\PYGZob{}}
    \PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{\PYGZus{}connection} \PYG{o}{=} \PYG{n+nx}{connection}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Why is this useful? Because the compiler can detect if the program is expecting a returning value from these methods and produce a compiler exception:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{myDb} \PYG{o}{=} \PYG{n+nx}{db}\PYG{o}{-\textgreater{}}\PYG{n+nx}{setConnection}\PYG{p}{(}\PYG{n+nx}{connection}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{myDb}\PYG{o}{-\textgreater{}}\PYG{n+nx}{execute}\PYG{p}{(}\PYG{l+s+s2}{"SELECT * FROM robots"}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// this will produce an exception}
\end{Verbatim}


\section{Control Structures}
\label{control:control-structures}\label{control::doc}
Zephir implements a simplified set of control structures present in similar languages like C, PHP etc.


\subsection{Conditionals}
\label{control:conditionals}

\subsubsection{If Statement}
\label{control:if-statement}
`if' statements evaluates an expression executing this trace if the evaluation is true.
Braces are compulsory, an `if' can have an optional `else' clause, multiple `if'/'else'
constructs can be chained together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{k+kc}{false} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{l+s+s2}{"false?"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{k+kc}{true} \PYG{p}{\PYGZob{}}
        \PYG{k}{echo} \PYG{l+s+s2}{"true!"}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{k}{echo} \PYG{l+s+s2}{"neither true nor false"}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Parentheses in the evaluated expression are optional:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n+nx}{a} \PYG{o}{\textless{}} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}} \PYG{k}{if} \PYG{n+nx}{a} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{Switch Statement}
\label{control:switch-statement}
A `switch' evalutes an expression against a series of predefined literal values executing the corresponding
`case' block or falling back to the `default' block case:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{switch} \PYG{n+nb}{count}\PYG{p}{(}\PYG{n+nx}{items}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{case} \PYG{l+m+mi}{1}\PYG{o}{:}
    \PYG{k}{case} \PYG{l+m+mi}{3}\PYG{o}{:}
        \PYG{k}{echo} \PYG{l+s+s2}{"odd items"}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{k}{case} \PYG{l+m+mi}{2}\PYG{o}{:}
    \PYG{k}{case} \PYG{l+m+mi}{4}\PYG{o}{:}
        \PYG{k}{echo} \PYG{l+s+s2}{"even items"}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{k}{default}\PYG{o}{:}
        \PYG{k}{echo} \PYG{l+s+s2}{"unknown items"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Loops}
\label{control:loops}

\subsubsection{While Statement}
\label{control:while-statement}
`while' denotes a loop that iterates as long as its given condition evaluates as true:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{counter} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k}{while} \PYG{n+nx}{counter} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{let} \PYG{n+nx}{counter} \PYG{o}{-=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{Loop Statement}
\label{control:loop-statement}
In addition to `while', `loop' can be used to create infinite loops:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{n} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{;}
\PYG{k}{loop} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{let} \PYG{n+nx}{n} \PYG{o}{-=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{if} \PYG{n+nx}{n} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{5} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}} \PYG{k}{break}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k}{echo} \PYG{n+nx}{x}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{For Statement}
\label{control:for-statement}
A `for' is a control structure that allows to traverse arrays or strings:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n+nx}{item} \PYG{k}{in} \PYG{p}{[}\PYG{l+s+s2}{"a"}\PYG{p}{,} \PYG{l+s+s2}{"b"}\PYG{p}{,} \PYG{l+s+s2}{"c"}\PYG{p}{,} \PYG{l+s+s2}{"d"}\PYG{p}{]} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{n+nx}{item}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Keys in hashes can be obtained in the following way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{"a"}\PYG{o}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s2}{"b"}\PYG{o}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{"c"}\PYG{o}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s2}{"d"}\PYG{o}{:} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}

\PYG{k}{for} \PYG{n+nx}{key}\PYG{p}{,} \PYG{n+nx}{value} \PYG{k}{in} \PYG{n+nx}{items} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{n+nx}{key}\PYG{p}{,} \PYG{l+s+s2}{" "}\PYG{p}{,} \PYG{n+nx}{value}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

A `for' loop can also be instructed to traverse an array or string in reverse order:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}

\PYG{k}{for} \PYG{n+nx}{value} \PYG{k}{in} \PYG{k+kr}{reverse} \PYG{n+nx}{items} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{n+nx}{value}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

A `for' can be used to traverse string variables:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{string} \PYG{n+nx}{language} \PYG{o}{=} \PYG{l+s+s2}{"zephir"}\PYG{p}{;} \PYG{k+kr}{char} \PYG{n+nx}{ch}\PYG{p}{;}

\PYG{k}{for} \PYG{n+nx}{ch} \PYG{k}{in} \PYG{n+nx}{language} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{l+s+s2}{"["}\PYG{p}{,} \PYG{n+nx}{ch} \PYG{l+s+s2}{"]"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In reverse order:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{string} \PYG{n+nx}{language} \PYG{o}{=} \PYG{l+s+s2}{"zephir"}\PYG{p}{;} \PYG{k+kr}{char} \PYG{n+nx}{ch}\PYG{p}{;}

\PYG{k}{for} \PYG{n+nx}{ch} \PYG{k}{in} \PYG{k+kr}{reverse} \PYG{n+nx}{language} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{l+s+s2}{"["}\PYG{p}{,} \PYG{n+nx}{ch} \PYG{l+s+s2}{"]"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

A standard `for' that traverses a range of integer values can be written as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n+nx}{i} \PYG{k}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{echo} \PYG{n+nx}{i}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{Break Statement}
\label{control:break-statement}
`break' ends execution of the current `while', `for' or `loop' statements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n+nx}{item} \PYG{k}{in} \PYG{p}{[}\PYG{l+s+s2}{"a"}\PYG{p}{,} \PYG{l+s+s2}{"b"}\PYG{p}{,} \PYG{l+s+s2}{"c"}\PYG{p}{,} \PYG{l+s+s2}{"d"}\PYG{p}{]} \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{n+nx}{item} \PYG{o}{==} \PYG{l+s+s2}{"c"} \PYG{p}{\PYGZob{}}
        \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{// exit the for}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{echo} \PYG{n+nx}{item}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{Continue Statement}
\label{control:continue-statement}
`continue' is used within looping structures to skip the rest of the current loop iteration and
continue execution at the condition evaluation and then the beginning of the next iteration.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{a} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k}{while} \PYG{n+nx}{a} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{let} \PYG{n+nx}{a}\PYG{o}{--}\PYG{p}{;}
    \PYG{k}{if} \PYG{n+nx}{a} \PYG{o}{==} \PYG{l+m+mi}{3} \PYG{p}{\PYGZob{}}
        \PYG{k}{continue}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{echo} \PYG{n+nx}{a}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZbs{}n"}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Require}
\label{control:require}
The `require' statement dynamically includes and evaluates a specified PHP file. Note that files
included via Zephir are interpreted by Zend Engine as normal PHP files. `require' does not allow to
include other zephir files in runtime.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n+nx}{file\PYGZus{}exists}\PYG{p}{(}\PYG{n+nx}{path}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{require} \PYG{n+nx}{path}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Let}
\label{control:let}
`Let' statement is used to mutate variables, properties and arrays. Variables are by default inmutable and this instruction makes them mutable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{name} \PYG{o}{=} \PYG{l+s+s2}{"Tony"}\PYG{p}{;}           \PYG{c+c1}{// simple variable}
\PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{name} \PYG{o}{=} \PYG{l+s+s2}{"Tony"}\PYG{p}{;}     \PYG{c+c1}{// object property}
\PYG{k+kd}{let} \PYG{n+nx}{data}\PYG{p}{[}\PYG{l+s+s2}{"name"}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{"Tony"}\PYG{p}{;}   \PYG{c+c1}{// array index}
\PYG{k+kd}{let} \PYG{k+kr}{self}\PYG{o}{:}\PYG{o}{:}\PYG{n+nx}{\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s2}{"Tony"}\PYG{p}{;}    \PYG{c+c1}{// static property}
\end{Verbatim}

Also this instruction must be used to increment/decrement variables:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{number}\PYG{o}{++}\PYG{p}{;}           \PYG{c+c1}{// increment simple variable}
\PYG{k+kd}{let} \PYG{n+nx}{number}\PYG{o}{--}\PYG{p}{;}           \PYG{c+c1}{// decrement simple variable}
\PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{number}\PYG{o}{++}\PYG{p}{;}     \PYG{c+c1}{// increment object property}
\PYG{k+kd}{let} \PYG{k}{this}\PYG{o}{-\textgreater{}}\PYG{n+nx}{number}\PYG{o}{--}\PYG{p}{;}     \PYG{c+c1}{// decrement object property}
\end{Verbatim}

Multiple mutations can be performed in a single `let' operation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{price} \PYG{o}{=} \PYG{l+m+mf}{1.00}\PYG{p}{,} \PYG{n+nx}{realPrice} \PYG{o}{=} \PYG{n+nx}{price}\PYG{p}{,} \PYG{n+nx}{status} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{;}
\end{Verbatim}


\section{Calling Functions}
\label{functions::doc}\label{functions:calling-functions}
PHP has a rich library of functions you can use in your extensions.
To call a PHP function, you can just refer its name in the Zephir code.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Encoder}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{encode}\PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{text}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{n+nx}{strlen}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n+nx}{base64\PYGZus{}encode}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can call also functions that are expected to exist in the PHP userland but they
aren't built-in with PHP:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Encoder}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{encode}\PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{text}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{n+nx}{strlen}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{n+nx}{function\PYGZus{}exists}\PYG{p}{(}\PYG{l+s+s2}{"my\PYGZus{}custom\PYGZus{}encoder"}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n+nx}{my\PYGZus{}custom\PYGZus{}encoder}\PYG{p}{(}\PYG{n+nx}{\PYGZdl{}text}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n+nx}{base64\PYGZus{}encode}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Note that all PHP functions only receive and return dynamic variables, if you pass a static typed
variable as a parameter, some temporary dynamic variable will be used as a bridge in order to call them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Encoder}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{encode}\PYG{p}{(}\PYG{k+kr}{string} \PYG{n+nx}{text}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{n+nx}{strlen}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// an implicit dynamic variable is created to}
            \PYG{c+c1}{// pass the static typed 'text' as parameter}
            \PYG{k}{return} \PYG{n+nx}{base64\PYGZus{}encode}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Similarly, functions return dynamic values that cannot be directly assigned to static
variables without the appropriate cast:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Encoder}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{encode}\PYG{p}{(}\PYG{k+kr}{string} \PYG{n+nx}{text}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kr}{string} \PYG{n+nx}{encoded} \PYG{o}{=} \PYG{l+s+s2}{""}\PYG{p}{;}

        \PYG{k}{if} \PYG{n+nx}{strlen}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
            \PYG{k+kd}{let} \PYG{n+nx}{encoded} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{string}\PYG{p}{)} \PYG{n+nx}{base64\PYGZus{}encode}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{l+s+s1}{'('} \PYG{p}{.} \PYG{n+nx}{encoded} \PYG{p}{.} \PYG{l+s+s1}{')'}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{k+kc}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Sometimes, we would need to call functions in a dynamic way, you can call them as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n+nx}{MyLibrary}\PYG{p}{;}

\PYG{k+kr}{class} \PYG{n+nx}{Encoder}
\PYG{p}{\PYGZob{}}

    \PYG{k+kr}{public} \PYG{k+kd}{function} \PYG{n+nx}{encode}\PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{callback}\PYG{p}{,} \PYG{k+kr}{string} \PYG{n+nx}{text}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{n+nx}{callback}\PYG{p}{\PYGZcb{}}\PYG{p}{(}\PYG{n+nx}{text}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Using optimizers}
\label{functions:using-optimizers}
Most common functions in Zephir use internal optimizers. An `optimizer' works like an interceptor for function calls.
An `optimizer' replaces the call for the function in the PHP userland by direct C-calls which are faster and have a lower
overhead improving performance.

To create an optimizer you have to create a class in the `optimizers' directory, the following convention must be used:

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{
Function in Zephir
} & \textbf{
Optimizer Class Name
} & \textbf{
Optimizer Path
} & \textbf{
Function in C
}\\\hline

calculate\_pi
 & 
CalculatePiOptimizer
 & 
optimizers/CalculatePiOptimizer.php
 & 
my\_calculate\_pi
\\\hline
\end{tabulary}


This is the basic structure for an `optimizer':

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{k}{class} \PYG{n+nc}{CalculatePiOptimizer} \PYG{k}{extends} \PYG{n+nx}{OptimizerAbstract}
\PYG{p}{\PYGZob{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{optimize}\PYG{p}{(}\PYG{k}{array} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{,} \PYG{n+nx}{Call} \PYG{n+nv}{\PYGZdl{}call}\PYG{p}{,} \PYG{n+nx}{CompilationContext} \PYG{n+nv}{\PYGZdl{}context}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//...}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Implementation of optimizers highly depends on the kind of code you want to generate. In our example, we're going to replace the call to this
function by a call to a c-function. In Zephir, the code used to call this function is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let} \PYG{n+nx}{pi} \PYG{o}{=} \PYG{n+nx}{calculate\PYGZus{}pi}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

So, the optimizer will expect just one parameter, we have to validate that to avoid problems later:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{optimize}\PYG{p}{(}\PYG{k}{array} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{,} \PYG{n+nx}{Call} \PYG{n+nv}{\PYGZdl{}call}\PYG{p}{,} \PYG{n+nx}{CompilationContext} \PYG{n+nv}{\PYGZdl{}context}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n+nb}{isset}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{]))} \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{'calculate\PYGZus{}pi' requires one parameter}\PYG{l+s+s2}{"}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{count}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{])} \PYG{o}{\textless{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{'calculate\PYGZus{}pi' requires one parameter}\PYG{l+s+s2}{"}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

There are functions that are just called and they don't return any value, our function returns a value that is the calculated PI value. So we need
to be aware that the type of the variable used to received this calculated value is OK:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{optimize}\PYG{p}{(}\PYG{k}{array} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{,} \PYG{n+nx}{Call} \PYG{n+nv}{\PYGZdl{}call}\PYG{p}{,} \PYG{n+nx}{CompilationContext} \PYG{n+nv}{\PYGZdl{}context}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n+nb}{isset}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{]))} \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{'calculate\PYGZus{}pi' requires one parameter}\PYG{l+s+s2}{"}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{count}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{])} \PYG{o}{\textless{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{'calculate\PYGZus{}pi' requires one parameter}\PYG{l+s+s2}{"}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Process the expected symbol to be returned}
\PYG{l+s+sd}{     */}
    \PYG{n+nv}{\PYGZdl{}call}\PYG{o}{-\textgreater{}}\PYG{n+na}{processExpectedReturn}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}context}\PYG{p}{);}

    \PYG{n+nv}{\PYGZdl{}symbolVariable} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}call}\PYG{o}{-\textgreater{}}\PYG{n+na}{getSymbolVariable}\PYG{p}{();}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nv}{\PYGZdl{}symbolVariable}\PYG{o}{-\textgreater{}}\PYG{n+na}{isNotDouble}\PYG{p}{())} \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{Calculated PI values only can be stored in double variables}\PYG{l+s+s2}{"}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

We're checking if the value returned will be stored in a variable type `double', if not a compiler exception is thrown.

The next thing we need to do is process the parameters passed to the function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{n+nv}{\PYGZdl{}resolvedParams} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}call}\PYG{o}{-\textgreater{}}\PYG{n+na}{getReadOnlyResolvedParams}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{],} \PYG{n+nv}{\PYGZdl{}context}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{);}
\end{Verbatim}

As a good practice with Zephir is important to create functions that don't modify their parameters, if you are changing the parameters
passed, Zephir will need to allocate memory for constants passed and you have to use getResolvedParams instead of getReadOnlyResolvedParams.

Code returned by these methods is valid C-code that can be used in the code printer to generate the c-function call:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{c+c1}{//Generate the C-code}
\PYG{k}{return} \PYG{k}{new} \PYG{n+nx}{CompiledExpression}\PYG{p}{(}\PYG{l+s+s1}{'double'}\PYG{p}{,} \PYG{l+s+s1}{'calculate\PYGZus{}pi( '} \PYG{o}{.} \PYG{n+nv}{\PYGZdl{}resolvedParams}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{.} \PYG{l+s+s1}{')'}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{);}
\end{Verbatim}

All optimizers must return a CompiledExpression instance, this will tell the compiler the type returned by the code and its related C-code.

The complete optimizer code is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php}

\PYG{k}{class} \PYG{n+nc}{CalculatePiOptimizer} \PYG{k}{extends} \PYG{n+nx}{OptimizerAbstract}
\PYG{p}{\PYGZob{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{optimize}\PYG{p}{(}\PYG{k}{array} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{,} \PYG{n+nx}{Call} \PYG{n+nv}{\PYGZdl{}call}\PYG{p}{,} \PYG{n+nx}{CompilationContext} \PYG{n+nv}{\PYGZdl{}context}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n+nb}{isset}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{]))} \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{'calculate\PYGZus{}pi' requires one parameter}\PYG{l+s+s2}{"}\PYG{p}{);}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{count}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{])} \PYG{o}{\textless{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{'calculate\PYGZus{}pi' requires one parameter}\PYG{l+s+s2}{"}\PYG{p}{);}
        \PYG{p}{\PYGZcb{}}

        \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{         * Process the expected symbol to be returned}
\PYG{l+s+sd}{         */}
        \PYG{n+nv}{\PYGZdl{}call}\PYG{o}{-\textgreater{}}\PYG{n+na}{processExpectedReturn}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}context}\PYG{p}{);}

        \PYG{n+nv}{\PYGZdl{}symbolVariable} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}call}\PYG{o}{-\textgreater{}}\PYG{n+na}{getSymbolVariable}\PYG{p}{();}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nv}{\PYGZdl{}symbolVariable}\PYG{o}{-\textgreater{}}\PYG{n+na}{isNotDouble}\PYG{p}{())} \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{k}{new} \PYG{n+nx}{CompilerException}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{Calculated PI values only can be stored in double variables}\PYG{l+s+s2}{"}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{);}
        \PYG{p}{\PYGZcb{}}

        \PYG{n+nv}{\PYGZdl{}resolvedParams} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}call}\PYG{o}{-\textgreater{}}\PYG{n+na}{getReadOnlyResolvedParams}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{[}\PYG{l+s+s1}{'parameters'}\PYG{p}{],} \PYG{n+nv}{\PYGZdl{}context}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{);}

        \PYG{k}{return} \PYG{k}{new} \PYG{n+nx}{CompiledExpression}\PYG{p}{(}\PYG{l+s+s1}{'double'}\PYG{p}{,} \PYG{l+s+s1}{'my\PYGZus{}calculate\PYGZus{}pi( '} \PYG{o}{.} \PYG{n+nv}{\PYGZdl{}resolvedParams}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{.} \PYG{l+s+s1}{')'}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}expression}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{License}
\label{license::doc}\label{license:license}
Copyright (c) 2013-2014 Zephir Team and contributors
\href{http://zephir-lang.com}{http://zephir-lang.com}

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ``Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


\chapter{Other Formats}
\label{index:other-formats}\begin{itemize}
\item {} 
\href{https://github.com/phalcon/zephir-docs/blob/master/en/\_build/latex/ZephirDocumentation.pdf?raw=true}{PDF}

\end{itemize}

\index{index!index}


\renewcommand{\indexname}{Index}
\printindex
\end{document}
