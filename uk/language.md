# Базовий синтаксис

У цьому розділі ми обговоримо організацію файлів, простори імен, оголошення змінних, різні синтаксичні конвенції та кілька інших загальних понять.

<a name='organizing-code-in-files-and-namespaces'></a>

## Розміщення коду в файлах та простори імен

У PHP ви можете розмістити код в будь-який файл, без конкретної структури. У Zephir кожен файл мусить містити клас (і тільки один клас). Кожен клас повинен мати простір імен, а структура каталогів повинна відповідати іменам класів та просторам імен. (Це схоже на PSR-4-автозавантажувальну конвенцію, за винятком того, що вона застосовується самою мовою.)

Наприклад, з огляду на наступну структуру кожен файл має мати наступні класи:

    mylibrary/
        router/
            exception.zep # MyLibrary\Router\Exception
        router.zep # MyLibrary\Router
    

Клас у `mylibrary/router.zep`:

    namespace MyLibrary;
    
    class Router
    {
    
    }
    

Клас у `mylibrary/router/exception.zep`:

    namespace MyLibrary\Router;
    
    class Exception extends \Exception
    {
    
    }
    

Zephir викине виняток (exception) компілятора, якщо файл або клас не знаходяться в очікуваному файлі, або навпаки.

<a name='instruction-separation'></a>

## Розділення інструкцій

Можливо, ви вже помітили, що в прикладах коду в попередньому розділі було дуже мало крапок з комою. Ви можете використовувати крапку з комою для відокремлення тверджень та виразів, як у Java, C/C++, PHP та подібних мовах:

    myObject->myMethod(1, 2, 3); echo "world";
    

<a name='comments'></a>

## Коментарі

Zephir підтримує коментарі в стилі 'C'/'C++'. Це однорядкові коментарі з `// ...`, та багаторядкові з `/* ... */`:

    // це однорядковий коментар
    
    /**
     * це багаторядковий
     * коментар
     */
    

У більшості мов коментарі це просто текст, який ігнорується компілятором/інтерпретатором. У Zephir-і багаторядкові коментарі також використовуються як док-блоки (docblocks) і вони експортуються до згенерованого коду, так що вони - частина мови!

Якщо док-блок не знаходиться там, де він очікується, компілятор викине виключення.

<a name='variable-declarations'></a>

## Оголошення змінних

У Zephir-і всі змінні, які використовуються в даній області видимості мають бути оголошені. Це дає компілятору можливість виконати оптимізацію та перевірки. Змінні мають бути унікальними ідентифікаторами. Ключові слова не можуть бути іменами змінних.

    // Оголошення змінних для одного і того ж типу в тій же інструкції
    var a, b, c;
    
    // Оголошення кожної змінної в окремому рядку
    var a;
    var b;
    var c;
    

Змінні можуть мати початкове сумісне значення:

    // Оголошення змінних зі значеннями за замовчуванням
    var a = "hello", b = 0, c = 1.0;
    int d = 50; bool some = true;
    

Імена змінних чутливі до регістру, наступні змінні є різними:

    // Різні змінні
    var somevalue, someValue, SomeValue;
    

<a name='variable-scope'></a>

## Область видимості

Усі оголошені в методі змінні залишаються в його локальній області видимості:

    namespace Test;
    
    class MyClass
    {
    
        public function someMethod1()
        {
            int a = 1, b = 2;
            return a + b;
        }
    
        public function someMethod2()
        {
            int a = 3, b = 4;
            return a + b;
        }
    
    }
    

<a name='super-global'></a>

## Суперглобальні змінні

Zephir не підтримує глобальні змінні - доступу до глобальних змінних з PHP немає. Однак, ви можете отримати доступ до суперглобальних змінних PHP наступним чином:

    // Отримання значення з _POST
    let price = _POST["price"];
    
    // Читання даних з _SERVER
    let requestMethod = _SERVER["REQUEST_METHOD"];
    

<a name='local-symbol-table'></a>

## Локальна таблиця символів

Кожен метод або контекст у PHP має таблицю символів, яка дозволяє вам записувати змінні у дуже гнучкий спосіб:

    <?php
    
    $b = 100;
    $a = "b";
    echo $$a; // надрукує 100
    

Zephir не передбачено реалізації цієї функціональності, тому що всі змінні компілюються до низькорівневих змінних, і немає ніякого способу дізнатися, які змінні існують у специфічному контексті. If you want to create a variable in the current PHP symbol table, you can use the following syntax:

    // Set variable $name in PHP
    let {"name"} = "hello";
    
    // Set variable $price in PHP
    let name = "price";
    let {name} = 10.2;